Question :

리눅스 기반 파일 시스템에서,

File descriptor와 Inode,
그리고 각 프로세스별로 FD를 어떻게 관리하는 지, Inode는 커널이 어떻게 관리하는 지가 궁금해.

정확히는, 다음과 같은 질문들을 해결해 줘.
리눅스 기반으로.

0. 파일디스크립터는 기본적으로 어떤 구조를 가지고 있으며, 각각의 역할은 어떻게 되나 ?
Inode도 같이 설명해 줘.

1. open(), close(), read(), write()의 syscall이 발생했을 때, 실제로 커널이 하는 일을 각각 소개해 줘.

2. 파일 디스크립터는 프로세스마다 할당될 것이지만, 결국에 연결된 파일은 1개란 말이지?
이런 공통된 파일을 여러 프로세스가 읽거나 쓰려고 할 때, 어떻게 제어하지?
Inode 혹은 FD 에 그런 제어를 담당하는 field가 있다면 그 것을 알려줘

3.
Java에서,  실제로 open(), close(), read(), write()가 발생할 떄,
Blocking - IO - Stream을 기반으로, Java 혹은 JVM 내부에서
어떤 일이 발생하고, 결국에 syscall은 어디서 수행되며 그 결과가 요청한 스레드로
어떻게 전달되는 지를 설명해 줘.

리눅스에서의 파일 디스크립터와 Inode 개념 정리 :

파일 디스크립터 :
프로세스가 열어 놓은 파일들을 가리키는 정수.
프로세스는 FD 테이블을 통해서 열어 놓은 파일들을 개별적으로 관리한다.
커널 레벨의 파일 객체인 file struct에서는
파일 상태(open, wr 어떤 정보가 있지? q1),
읽기 및 쓰기 포이터 위치, 그리고 파일이 어떤 inode인지 가리키는 포인터가 존재한다.

Inode :
파일 시스템 내의 파일 정보(메타데이터)를 담고 있는 구조체
파일의 종류, 권한, 소유자, 파일 크기, 실제 디스크 위치 등이 담겨 있다.
결국, 디스크 상에 존재하는 파일을 어떻게 읽고 쓰고, 접근하는 지에 대해 필요한 정보를 갖는다.
커널이 파일을 접근할 떄 inode를 통해서 정보를 얻음.

open(path, flags, mode) :
path : 파일이 속해 있는 경로
flags : 파일에 대한 어떤 접근인지를 담는 정보(읽기, 쓰기, 실행)
mode : ? (q1)

커널은 전달받은 path를 활용해서 해당 파일이 어디에 존재하는 지를 찾고,
접근 권한을 확인해서 현재의 유저가 해당 파일에 접근 가능한 지를 inode의 정보를 이용해 활용한 뒤,
새로운 파일 객체를 만들어서 필요한 정보를 기록한 뒤, 프로세스의 FD 테이블에 넣는다.

close(fd) :
커널은 현재 프로세스의 파일 디스크립터 테이블에서 fd에 해당하는 파일을 찾아,
해당 파일 객체를 해제한다.

read(fd, *buf, count) :
프로세스의 FD 테이블에서 fd에 해당하는 파일을 찾은 뒤,
해당 파일의 메타데이터로부터 현재 읽기가 가능한 지, 가능하다면 파일의 실제 위치(inode)는 어디에 있는지
등을 화인한 뒤, 파일의 오프셋부터, count만큼 디스크 -> 커널로 정보를 복사한 뒤,
사용자 공간에 해당하는 주소인 buf에 해당 정보를 복사함.
마지막으로, 읽은 바이트 수만큼 파일의 pos를 증가.

write(fd, *buf, count) :
FD의 유효성과 접근 권한을 확인한 뒤,
파일의 쓰기 오프셋부터, count만큼 *buf에 담긴 정보를 커널 메모리로 복사한다.
이후, 커널 메모리에서 다시 디스크 블록으로 데이터를 기록한다.
이후, 쓴 바이트만큼 쓰기 오프셋을 증가시킨다.

q0. 내가 정리한 개념 중에 틀린 부분이 잇다면 지적하고, 종합해서 내용을 정리하라.
또한, struct file은 어떤 정보 및 객체를 담고, 각각의 필드는 어떤 역할을 할 지 정리하라.

q1. mode는 어떤 역할을 하는지 ?

커널에서의 파일 접근 통제 관련 질문 :

커널에서 파일에 대한 접근을 어떻게 통제하는 지?
q1. inode에서 락을 한다고 했는데, 파일 시스템에서 사용되는
락의 대표적인 동작 방식이 어떻게 되는지 ?

q2. 프로세스 1과 프로세스 2가.
output.txt라는 텍스트 파일에, 동시에 접근해서, 밑의 코드
for (int i = 1 ~ 100):
    write("process %d, %dth line\n", process.id, i)

를 실행한다고 해보자. q1에서 제공한 락의 메커니즘이 현재의 코드에서
어떻게 동작하는 지를 설명해라.

q3.
q2에서의 코드를 동작할 때,
write에서 fd 별로 write offset을 관리한다면,
output.txt는 총 100줄, 그리고
각 줄에는 프로세스 1 또는 2 가 실행한 라인들이 적히게 된다. 맞나?
(왜냐하면, 각 프로세스별로 fos를 관리하기 때문에,
만약 프로세스1 이 10줄을 적은 뒤 프로세스 2가 1줄을 적게 된다면,
11번째 줄에 적는 게 아니라 1번째 줄에 적을 것이기 때문)
내가 이해한 write_fos의 semantics가 일반적인 리눅스의 write_fos의 동작 과정과 같은 지 확인해 달라.


이제 내가 궁금한 게 뭔지 이해가 ㅈ


프로세스 스케쥴링 및 interrupt, 커널 프로세스 관련해서 정리 필요.


1. Inode 구조체에서 담고 있는 정보들을 알려줘

2. File 객체로부터 Inode에 접근할 떄,
시작지점은 어디가 돼? 항상 파일의 처음부분인 거야?

예를 들어서, 특별한 설정 없이 output.txt에 접근할 때, 항상
pos(오프셋)을 더하는 시작지점은 output.txt에 처음인 거야?
